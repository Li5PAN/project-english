# 英语学习系统 - 关键技术说明文档

## 项目概述

本项目采用前后端分离架构，前端使用 Vue 3 + JavaScript + Ant Design Vue + ECharts 技术栈，后端基于 Spring Boot + MyBatis + Spring Security 框架，实现了一个面向学生、教师、管理员三种角色的英语学习管理系统。

## 技术架构概述

本系统采用前后端分离的 B/S 架构模式进行设计与开发，整体技术栈涵盖了前端展示层、后端业务层和数据持久层三个核心部分。在前端技术方面，系统使用 Vue 3 作为核心框架，采用 Composition API 实现组件化开发和业务逻辑复用；通过 Vue Router 实现基于角色的路由权限控制，确保学生、教师、管理员三种角色的页面访问隔离；引入 Ant Design Vue 企业级组件库快速构建统一风格的用户界面，包括表格、表单、对话框等常用组件；使用 Axios 封装 HTTP 请求，实现统一的 Token 认证和错误处理机制。在后端技术方面，系统基于 Spring Boot 框架构建 RESTful API 服务，采用多模块聚合工程按功能拆分为 common、security、user、class、word、task 等模块，结构清晰便于维护；使用 MyBatis 作为持久层框架，通过 XML 映射文件和注解方式实现灵活的 SQL 操作；集成 Spring Security 实现基于 RBAC 的权限控制模型，结合自定义注解 @DataScope 实现数据级权限过滤，确保用户只能访问各自权限范围内的数据；采用 MySQL 关系型数据库存储用户信息、班级数据、单词库、学习记录等核心业务数据，通过合理的表结构设计和索引优化保证系统性能。整体技术架构遵循 MVC 设计模式，前端负责视图展示和用户交互，后端负责业务逻辑处理和数据管理，通过 RESTful API 进行数据交互，实现了前后端的解耦和独立开发部署。

---

## 一、前端关键技术（4项核心技术）

### 1. Vue 3 Composition API（核心框架）

**技术说明：**
- 使用 Vue 3.5.24 版本，采用 Composition API 和 `<script setup>` 语法糖
- 相比 Vue 2 的 Options API，提供更灵活的逻辑组织和代码复用能力

**使用目的：**
- **逻辑复用**：通过组合式函数（Composables）实现业务逻辑的模块化和复用，例如单词学习、任务管理等功能模块
- **类型推导**：配合 `<script setup>` 语法糖，减少样板代码，提升开发效率
- **性能优化**：利用 Vue 3 的响应式系统（Proxy），实现更精准的依赖追踪和更新
- **代码组织**：将相关的状态、方法、生命周期钩子组织在一起，提高代码可读性和维护性

**项目应用场景：**
```javascript
// 示例：学生单词学习页面 (word-learn.vue)
<script setup>
import { ref, onMounted } from 'vue'

const currentWord = ref(null)
const userAnswer = ref('')
const isCorrect = ref(null)

const loadWord = async () => {
  // 加载单词逻辑
}

const checkAnswer = () => {
  // 检查答案逻辑
}

onMounted(() => {
  loadWord()
})
</script>
```

---

### 2. Vite 构建工具（开发与构建）

**技术说明：**
- 使用 Vite 7.2.4 作为前端构建工具
- 基于 ES Module 的开发服务器，提供极速的冷启动和热更新

**使用目的：**
- **快速开发**：利用浏览器原生 ES Module 支持，实现毫秒级的热模块替换（HMR）
- **开发代理**：配置开发服务器代理，解决跨域问题，将 `/api` 请求转发到后端服务器
- **环境变量管理**：通过 `.env` 文件管理不同环境的配置（开发、生产）
- **优化构建**：生产环境自动进行代码分割、压缩、Tree-shaking，减小包体积

**项目配置示例：**
```javascript
// vite.config.js
export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd())
  
  return {
    plugins: [vue()],
    server: {
      port: Number(env.VITE_PORT) || 3000,
      proxy: {
        '/api': {
          target: env.VITE_PROXY_DOMAIN_REAL,
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/api/, '')
        }
      }
    }
  }
})
```

---

### 3. Ant Design Vue 组件库（UI 框架）

**技术说明：**
- 使用 Ant Design Vue 4.2.6 版本
- 企业级 UI 设计语言和 Vue 组件库，提供 60+ 高质量组件

**使用目的：**
- **快速开发**：使用现成的表格（Table）、表单（Form）、对话框（Modal）、消息提示（Message）等组件，减少重复开发
- **统一设计**：保持整个系统的视觉风格一致，提升用户体验
- **响应式布局**：利用 Layout、Grid 组件实现自适应布局，适配不同屏幕尺寸
- **交互体验**：提供丰富的交互组件（日期选择器、下拉菜单、分页器等），提升操作便捷性

**项目应用场景：**
- **用户管理页面**：使用 `a-table` 展示用户列表，`a-modal` 实现新增/编辑用户弹窗
- **任务管理页面**：使用 `a-form` 创建任务表单，`a-select` 选择班级和学生
- **数据展示**：使用 `a-card`、`a-statistic` 展示统计数据
- **消息提示**：使用 `message.success()`、`message.error()` 提供操作反馈

```javascript
// 示例：表格和表单组件使用
<a-table 
  :columns="columns" 
  :data-source="dataSource" 
  :pagination="pagination"
  @change="handleTableChange"
/>

<a-modal v-model:open="visible" title="新增用户">
  <a-form :model="formData" :rules="rules">
    <a-form-item label="用户名" name="username">
      <a-input v-model:value="formData.username" />
    </a-form-item>
  </a-form>
</a-modal>
```

---

### 4. Vue Router 路由管理（页面导航与权限控制）

**技术说明：**
- 使用 Vue Router 5.0.2 版本
- 采用模块化路由配置，通过 `import.meta.glob` 自动加载路由模块

**使用目的：**
- **角色权限控制**：通过路由守卫（beforeEach）实现基于角色的访问控制（RBAC）
- **模块化管理**：将学生、教师、管理员的路由分别放在独立模块中，便于维护
- **路由懒加载**：使用动态 import 实现按需加载，减少首屏加载时间
- **导航守卫**：统一处理登录验证、权限校验、页面跳转逻辑

**项目实现要点：**
```javascript
// 路由守卫核心逻辑
router.beforeEach((to, from, next) => {
  const userInfo = JSON.parse(localStorage.getItem('userInfo'))
  const hasToken = !!userInfo
  const userRole = userInfo?.role

  // 白名单路由（登录、注册）直接放行
  const whiteList = ['/login', '/register']
  if (whiteList.includes(to.path)) {
    next()
    return
  }

  // 未登录跳转到登录页
  if (!hasToken || !userRole) {
    next('/login')
    return
  }

  // 检查路由权限（学生只能访问学生路由）
  const routeRole = to.meta?.role
  if (routeRole && routeRole !== userRole) {
    next(roleRouteMap[userRole] || '/login')
    return
  }

  next()
})
```

**路由模块化结构：**
```
src/router/
├── index.js              # 路由主文件
└── modules/
    ├── student.js        # 学生路由模块
    ├── teacher.js        # 教师路由模块
    └── admin.js          # 管理员路由模块
```

---

### 5. ECharts 数据可视化（学习数据分析）

**技术说明：**
- 使用 ECharts 6.0.0 版本
- 百度开源的数据可视化库，支持多种图表类型

**使用目的：**
- **学习进度可视化**：使用折线图展示学生的学习进度趋势
- **班级数据分析**：使用柱状图、饼图展示班级整体学习情况
- **错题统计**：使用雷达图展示学生在不同题型的错误分布
- **交互式图表**：支持图表缩放、数据筛选、tooltip 提示等交互功能

**项目应用场景：**
- **学生端 - 我的进度页面**：展示个人学习曲线、单词掌握情况
- **教师端 - 班级数据页面**：展示班级学习统计、学生排名、任务完成率
- **管理员端 - 数据看板**：展示全局数据统计、用户活跃度、系统使用情况

```javascript
// 示例：ECharts 图表初始化
import * as echarts from 'echarts'

const initChart = () => {
  const chartDom = document.getElementById('chart')
  const myChart = echarts.init(chartDom)
  
  const option = {
    title: { text: '学习进度统计' },
    tooltip: { trigger: 'axis' },
    xAxis: { type: 'category', data: ['周一', '周二', '周三', '周四', '周五'] },
    yAxis: { type: 'value' },
    series: [{
      name: '学习单词数',
      type: 'line',
      data: [20, 35, 28, 42, 38]
    }]
  }
  
  myChart.setOption(option)
}
```

---

### 6. Axios HTTP 请求库（网络通信）

**技术说明：**
- 使用 Axios 1.13.4 版本
- 基于 Promise 的 HTTP 客户端，支持浏览器和 Node.js

**使用目的：**
- **统一请求封装**：创建统一的请求实例，配置基础 URL、超时时间等全局参数
- **请求/响应拦截**：通过拦截器自动添加 Token 到请求头，实现身份认证
- **错误统一处理**：拦截响应错误，统一处理 401（未授权跳转登录）、500（服务器错误提示）等状态码
- **取消重复请求**：防止用户快速点击导致的重复请求，优化用户体验

**项目应用场景：**
```javascript
// 示例：Axios 请求封装
import axios from 'axios'
import { message } from 'ant-design-vue'

const service = axios.create({
  baseURL: '/api',
  timeout: 10000
})

// 请求拦截器：添加 Token
service.interceptors.request.use(
  config => {
    const userInfo = JSON.parse(localStorage.getItem('userInfo'))
    if (userInfo?.token) {
      config.headers['Authorization'] = `Bearer ${userInfo.token}`
    }
    return config
  },
  error => Promise.reject(error)
)

// 响应拦截器：统一错误处理
service.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response?.status === 401) {
      message.error('登录已过期，请重新登录')
      localStorage.removeItem('userInfo')
      window.location.href = '/login'
    } else if (error.response?.status === 500) {
      message.error('服务器错误，请稍后重试')
    }
    return Promise.reject(error)
  }
)

export default service
```

**实际使用示例：**
- **用户登录**：`POST /api/auth/login` 提交用户名密码
- **获取单词列表**：`GET /api/words?page=1&size=20` 分页查询单词
- **提交学习记录**：`POST /api/learning/record` 记录学习进度
- **换班申请**：`POST /api/class/change-request` 提交换班申请

---

### 7. LocalStorage 本地存储（状态持久化）

**技术说明：**
- 浏览器原生 Web Storage API
- 提供 5-10MB 的本地存储空间，数据持久化保存

**使用目的：**
- **用户信息缓存**：存储登录用户的基本信息（用户名、角色、Token）
- **免登录功能**：页面刷新后自动读取本地用户信息，无需重新登录
- **权限判断依据**：路由守卫通过读取 LocalStorage 中的角色信息进行权限校验
- **学习进度缓存**：临时保存用户的学习状态，防止意外关闭页面导致数据丢失

**项目应用场景：**
```javascript
// 示例：用户信息管理
// 登录成功后保存用户信息
const saveUserInfo = (userInfo) => {
  localStorage.setItem('userInfo', JSON.stringify({
    id: userInfo.id,
    username: userInfo.username,
    role: userInfo.role,  // student/teacher/admin
    token: userInfo.token,
    classId: userInfo.classId
  }))
}

// 获取当前登录用户信息
const getUserInfo = () => {
  const userInfoStr = localStorage.getItem('userInfo')
  return userInfoStr ? JSON.parse(userInfoStr) : null
}

// 退出登录清除用户信息
const logout = () => {
  localStorage.removeItem('userInfo')
  window.location.href = '/login'
}

// 检查用户是否登录
const isLoggedIn = () => {
  const userInfo = getUserInfo()
  return !!userInfo && !!userInfo.token
}
```

**存储数据结构：**
```json
{
  "userInfo": {
    "id": 1001,
    "username": "student001",
    "role": "student",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "classId": 101,
    "className": "英语一班"
  }
}
```

**安全注意事项：**
- 不存储敏感信息（密码、完整身份证号等）
- Token 设置合理的过期时间，后端验证 Token 有效性
- 配合 HTTPS 传输，防止中间人攻击

---

## 其他辅助技术

### 8. Day.js 时间处理库

**使用目的：**
- 格式化日期时间显示（任务截止时间、学习记录时间）
- 计算时间差（任务剩余时间、学习时长统计）
- 轻量级替代 Moment.js，减小打包体积（仅 2KB）

**应用示例：**
```javascript
import dayjs from 'dayjs'

// 格式化时间显示
const formatTime = (time) => dayjs(time).format('YYYY-MM-DD HH:mm:ss')

// 计算任务剩余时间
const getRemainDays = (deadline) => {
  return dayjs(deadline).diff(dayjs(), 'day')
}
```

### 9. Crypto-js 加密库

**使用目的：**
- 对敏感信息（密码）进行加密传输
- 使用 MD5/SHA256 等算法加密，保证数据传输安全性

**应用示例：**
```javascript
import CryptoJS from 'crypto-js'

// 密码加密
const encryptPassword = (password) => {
  return CryptoJS.SHA256(password).toString()
}
```

---

## 二、后端关键技术（3项核心技术）

### 1. Spring Boot 框架（后端核心框架）

**技术说明：**
- 基于 Spring Framework 的快速开发框架
- 采用"约定优于配置"的设计理念，简化 Spring 应用的初始搭建和开发过程
- 内置 Tomcat 服务器，支持独立运行，无需外部容器

**使用目的：**
- **快速开发**：通过自动配置和起步依赖，快速搭建企业级应用框架
- **模块化架构**：采用多模块聚合工程，按功能拆分为 common（公共模块）、security（安全模块）、user（用户模块）、class（班级模块）、word（单词模块）、task（任务模块）、errorbook（错题本模块）、dashboard（数据看板模块）等，结构清晰便于维护
- **RESTful API**：提供标准的 RESTful 风格接口，支持前后端分离架构
- **依赖注入**：通过 IoC 容器管理对象生命周期，降低组件间耦合度

**项目应用场景：**
```java
// 示例：用户登录接口
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/login")
    public Result<LoginVO> login(@RequestBody LoginDTO loginDTO) {
        // 验证用户名密码
        User user = userService.authenticate(loginDTO.getUsername(), loginDTO.getPassword());
        
        // 生成 Token
        String token = JwtUtil.generateToken(user.getId(), user.getRole());
        
        // 返回用户信息和 Token
        LoginVO loginVO = new LoginVO();
        loginVO.setId(user.getId());
        loginVO.setUsername(user.getUsername());
        loginVO.setRole(user.getRole());
        loginVO.setToken(token);
        
        return Result.success(loginVO);
    }
}
```

**模块划分示例：**
```
english-study-backend/
├── common/                    # 公共模块
│   ├── utils/                # 工具类（日期、加密、JSON等）
│   ├── exception/            # 统一异常处理
│   └── result/               # 统一返回结果封装
├── security/                  # 安全模块
│   ├── config/               # Spring Security 配置
│   ├── filter/               # JWT 过滤器
│   └── annotation/           # 权限注解 @DataScope
├── user/                      # 用户模块
│   ├── controller/           # 用户管理接口
│   ├── service/              # 用户业务逻辑
│   └── mapper/               # 用户数据访问
├── class/                     # 班级模块
├── word/                      # 单词模块
├── task/                      # 任务模块
├── errorbook/                 # 错题本模块
└── dashboard/                 # 数据看板模块
```

---

### 2. MyBatis 持久层框架（数据访问层）

**技术说明：**
- 优秀的持久层框架，支持自定义 SQL、存储过程和高级映射
- 通过 XML 或注解方式配置和映射原生信息，将 POJO 映射成数据库中的记录
- 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集

**使用目的：**
- **灵活的 SQL 控制**：支持复杂查询、动态 SQL、多表关联，满足业务需求
- **数据权限过滤**：配合 @DataScope 注解，动态拼接 SQL 实现数据级权限控制
- **性能优化**：支持一级缓存、二级缓存，减少数据库访问次数
- **结果映射**：自动将查询结果映射为 Java 对象，简化开发

**项目应用场景：**
```java
// 示例：学生学习记录查询（带数据权限过滤）
@Mapper
public interface LearningRecordMapper {
    
    /**
     * 查询学习记录列表（学生只能看自己的，教师能看本班的）
     * @DataScope 注解会根据用户角色动态拼接 WHERE 条件
     */
    @DataScope(userAlias = "lr", classAlias = "c")
    List<LearningRecord> selectLearningRecordList(LearningRecordQuery query);
}
```

```xml
<!-- MyBatis XML 映射文件示例 -->
<mapper namespace="com.example.mapper.LearningRecordMapper">
    
    <select id="selectLearningRecordList" resultType="LearningRecord">
        SELECT 
            lr.id,
            lr.user_id,
            lr.word_id,
            lr.is_correct,
            lr.learn_time,
            u.username,
            w.word,
            w.translation
        FROM learning_record lr
        LEFT JOIN user u ON lr.user_id = u.id
        LEFT JOIN word w ON lr.word_id = w.id
        LEFT JOIN class c ON u.class_id = c.id
        WHERE 1=1
        <if test="userId != null">
            AND lr.user_id = #{userId}
        </if>
        <if test="startTime != null">
            AND lr.learn_time &gt;= #{startTime}
        </if>
        <if test="endTime != null">
            AND lr.learn_time &lt;= #{endTime}
        </if>
        <!-- @DataScope 注解会在这里动态插入权限过滤条件 -->
        ${dataScope}
        ORDER BY lr.learn_time DESC
    </select>
    
</mapper>
```

**数据权限过滤实现：**
- **学生角色**：自动添加 `AND lr.user_id = 当前用户ID`，只能查看自己的数据
- **教师角色**：自动添加 `AND c.teacher_id = 当前教师ID`，只能查看本班学生数据
- **管理员角色**：无额外过滤条件，可以查看所有数据

---

### 3. Spring Security 安全框架（权限控制）

**技术说明：**
- Spring 生态中的安全框架，提供认证（Authentication）和授权（Authorization）功能
- 支持多种认证方式（表单登录、JWT、OAuth2 等）
- 基于过滤器链实现请求拦截和权限校验

**使用目的：**
- **身份认证**：通过 JWT Token 实现无状态的用户身份验证
- **权限控制**：基于 RBAC（基于角色的访问控制）模型，实现接口级权限控制
- **数据权限**：结合自定义注解 @DataScope 实现数据级权限过滤
- **安全防护**：防止 CSRF 攻击、XSS 攻击，保护系统安全

**项目应用场景：**
```java
// 示例：Spring Security 配置
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 禁用 CSRF（前后端分离使用 Token 认证）
            .csrf().disable()
            // 配置请求授权规则
            .authorizeHttpRequests(auth -> auth
                // 登录、注册接口允许匿名访问
                .requestMatchers("/api/auth/login", "/api/auth/register").permitAll()
                // 学生接口需要 STUDENT 角色
                .requestMatchers("/api/student/**").hasRole("STUDENT")
                // 教师接口需要 TEACHER 角色
                .requestMatchers("/api/teacher/**").hasRole("TEACHER")
                // 管理员接口需要 ADMIN 角色
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                // 其他请求需要认证
                .anyRequest().authenticated()
            )
            // 添加 JWT 过滤器
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
            // 配置异常处理
            .exceptionHandling()
                .authenticationEntryPoint(unauthorizedHandler)
                .accessDeniedHandler(accessDeniedHandler);
        
        return http.build();
    }
}
```

```java
// 示例：JWT 认证过滤器
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain filterChain) throws ServletException, IOException {
        // 1. 从请求头获取 Token
        String token = request.getHeader("Authorization");
        
        if (token != null && token.startsWith("Bearer ")) {
            token = token.substring(7);
            
            try {
                // 2. 验证 Token 并解析用户信息
                Claims claims = JwtUtil.parseToken(token);
                Long userId = claims.get("userId", Long.class);
                String role = claims.get("role", String.class);
                
                // 3. 构建认证对象并存入 SecurityContext
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(userId, null, 
                        Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + role)));
                
                SecurityContextHolder.getContext().setAuthentication(authentication);
                
            } catch (Exception e) {
                // Token 无效或过期
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                return;
            }
        }
        
        // 4. 继续执行过滤器链
        filterChain.doFilter(request, response);
    }
}
```

```java
// 示例：自定义数据权限注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DataScope {
    /**
     * 用户表别名
     */
    String userAlias() default "";
    
    /**
     * 班级表别名
     */
    String classAlias() default "";
}

// 数据权限切面处理
@Aspect
@Component
public class DataScopeAspect {
    
    @Around("@annotation(dataScope)")
    public Object around(ProceedingJoinPoint point, DataScope dataScope) throws Throwable {
        // 获取当前登录用户信息
        Long userId = SecurityUtils.getCurrentUserId();
        String role = SecurityUtils.getCurrentUserRole();
        
        // 根据角色生成数据权限 SQL
        String dataScopeSql = "";
        if ("STUDENT".equals(role)) {
            // 学生只能看自己的数据
            dataScopeSql = String.format("AND %s.user_id = %d", dataScope.userAlias(), userId);
        } else if ("TEACHER".equals(role)) {
            // 教师只能看本班学生的数据
            Long teacherId = userId;
            dataScopeSql = String.format("AND %s.teacher_id = %d", dataScope.classAlias(), teacherId);
        }
        // 管理员无限制
        
        // 将 SQL 注入到查询参数中
        Object[] args = point.getArgs();
        for (Object arg : args) {
            if (arg instanceof BaseQuery) {
                ((BaseQuery) arg).setDataScope(dataScopeSql);
            }
        }
        
        return point.proceed(args);
    }
}
```

**权限控制三层防护：**
1. **接口级权限**：通过 Spring Security 配置，不同角色只能访问对应的接口
2. **方法级权限**：通过 @PreAuthorize 注解，细粒度控制方法访问权限
3. **数据级权限**：通过 @DataScope 注解，动态拼接 SQL 确保用户只能访问自己权限范围内的数据

---

## 三、数据库技术

### MySQL 关系型数据库

**技术说明：**
- 开源的关系型数据库管理系统，支持 ACID 事务
- 支持多种存储引擎（InnoDB、MyISAM 等）

**使用目的：**
- **数据持久化**：存储用户信息、班级数据、单词库、学习记录、任务信息等核心业务数据
- **事务支持**：保证换班流程、任务发布等关键业务的数据一致性
- **索引优化**：通过合理的索引设计提升查询性能
- **数据完整性**：通过外键约束、唯一约束保证数据完整性

**核心数据表设计：**
```sql
-- 用户表
CREATE TABLE user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role ENUM('STUDENT', 'TEACHER', 'ADMIN') NOT NULL,
    class_id BIGINT,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_class_id (class_id)
);

-- 班级表
CREATE TABLE class (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    class_name VARCHAR(100) NOT NULL,
    teacher_id BIGINT NOT NULL,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_teacher_id (teacher_id)
);

-- 单词表
CREATE TABLE word (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    word VARCHAR(100) NOT NULL,
    translation VARCHAR(500) NOT NULL,
    phonetic VARCHAR(100),
    difficulty TINYINT,
    INDEX idx_word (word)
);

-- 学习记录表
CREATE TABLE learning_record (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    word_id BIGINT NOT NULL,
    is_correct BOOLEAN NOT NULL,
    learn_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_word_id (word_id),
    INDEX idx_learn_time (learn_time)
);

-- 任务表
CREATE TABLE task (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    task_name VARCHAR(200) NOT NULL,
    class_id BIGINT NOT NULL,
    word_count INT NOT NULL,
    deadline DATETIME NOT NULL,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_class_id (class_id),
    INDEX idx_deadline (deadline)
);
```

---

## 四、技术架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          系统技术架构                                 │
├─────────────────────────────────────────────────────────────────────┤
│  前端层（Vue 3 + Ant Design Vue）                                    │
│    ├── 学生端：单词学习、任务管理、进度查看、错题本、换班申请          │
│    ├── 教师端：班级管理、任务发布、学生审核、数据分析                  │
│    └── 管理员：用户管理、班级管理、系统配置                            │
├─────────────────────────────────────────────────────────────────────┤
│  路由层（Vue Router）                                                 │
│    ├── 路由守卫：前端权限校验                                         │
│    ├── 角色路由：student/teacher/admin 模块化路由                     │
│    └── Token 验证：LocalStorage 用户信息管理                          │
├─────────────────────────────────────────────────────────────────────┤
│  HTTP 通信层（Axios）                                                 │
│    ├── 请求拦截：自动添加 Token                                       │
│    ├── 响应拦截：统一错误处理                                         │
│    └── RESTful API：前后端数据交互                                    │
├─────────────────────────────────────────────────────────────────────┤
│  后端控制层（Spring Boot + Spring MVC）                               │
│    ├── AuthController：登录、注册、Token 生成                         │
│    ├── StudentController：学生功能接口                                │
│    ├── TeacherController：教师功能接口                                │
│    └── AdminController：管理员功能接口                                │
├─────────────────────────────────────────────────────────────────────┤
│  安全层（Spring Security）                                            │
│    ├── JWT 过滤器：Token 验证和解析                                   │
│    ├── 接口权限：基于角色的访问控制（RBAC）                            │
│    └── 数据权限：@DataScope 注解动态 SQL 过滤                         │
├─────────────────────────────────────────────────────────────────────┤
│  业务逻辑层（Service）                                                │
│    ├── UserService：用户管理、认证授权                                │
│    ├── ClassService：班级管理、换班审核                               │
│    ├── WordService：单词管理、学习记录                                │
│    ├── TaskService：任务发布、完成度统计                              │
│    └── DashboardService：数据聚合、统计分析                           │
├─────────────────────────────────────────────────────────────────────┤
│  数据访问层（MyBatis）                                                │
│    ├── Mapper 接口：定义数据访问方法                                  │
│    ├── XML 映射：复杂 SQL、动态 SQL、多表关联                         │
│    └── 数据权限：动态拼接 WHERE 条件                                  │
├─────────────────────────────────────────────────────────────────────┤
│  数据库层（MySQL）                                                    │
│    ├── 用户表：user（用户信息、角色）                                 │
│    ├── 班级表：class（班级信息、教师关联）                            │
│    ├── 单词表：word（单词库）                                         │
│    ├── 学习记录表：learning_record（学习历史）                        │
│    ├── 任务表：task（学习任务）                                       │
│    └── 错题表：error_book（错题记录）                                 │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 五、关键业务流程技术实现

### 1. 用户登录认证流程

```
前端（Vue 3 + Axios）                后端（Spring Boot + Spring Security）
     │                                          │
     │  1. 提交用户名密码                        │
     ├──────────POST /api/auth/login──────────>│
     │                                          │ 2. 验证用户名密码
     │                                          │    UserService.authenticate()
     │                                          │
     │                                          │ 3. 生成 JWT Token
     │                                          │    JwtUtil.generateToken()
     │                                          │
     │  4. 返回用户信息 + Token                  │
     │<─────────────────────────────────────────┤
     │                                          │
     │  5. 存储到 LocalStorage                   │
     │     localStorage.setItem('userInfo')     │
     │                                          │
     │  6. 跳转到对应角色首页                     │
     │     router.push('/student/home')         │
```

### 2. 数据权限过滤流程

```
前端请求                    后端处理                      数据库查询
    │                          │                              │
    │  GET /api/student/       │                              │
    │  learning-records        │                              │
    ├────────────────────────>│                              │
    │  Header: Authorization   │                              │
    │                          │                              │
    │                          │ 1. JWT 过滤器验证 Token       │
    │                          │    解析出 userId=1001        │
    │                          │    role=STUDENT              │
    │                          │                              │
    │                          │ 2. @DataScope 切面拦截       │
    │                          │    生成 SQL 过滤条件：        │
    │                          │    AND user_id = 1001        │
    │                          │                              │
    │                          │ 3. MyBatis 执行查询          │
    │                          ├────────────────────────────>│
    │                          │  SELECT * FROM learning_     │
    │                          │  record WHERE user_id=1001   │
    │                          │                              │
    │                          │ 4. 返回查询结果               │
    │                          │<─────────────────────────────┤
    │                          │                              │
    │  5. 返回 JSON 数据        │                              │
    │<─────────────────────────┤                              │
```

### 3. 换班申请业务流程（事务控制）

```java
@Service
@Transactional
public class ClassService {
    
    public void processClassChange(Long studentId, Long targetClassId) {
        // 1. 校验任务完成度（必须完成当前班级所有任务）
        int unfinishedTasks = taskMapper.countUnfinishedTasks(studentId);
        if (unfinishedTasks > 0) {
            throw new BusinessException("请先完成当前班级的所有任务");
        }
        
        // 2. 更新学生班级归属
        userMapper.updateClassId(studentId, targetClassId);
        
        // 3. 记录换班审核日志
        ClassChangeLog log = new ClassChangeLog();
        log.setStudentId(studentId);
        log.setTargetClassId(targetClassId);
        log.setStatus("APPROVED");
        log.setApproveTime(new Date());
        classChangeLogMapper.insert(log);
        
        // 任意一步失败，整个事务自动回滚，保证数据一致性
    }
}
```

---

## 六、开发规范

### 1. 前端开发规范
- 组件命名：使用 kebab-case 命名（如 `word-learn.vue`）
- 组件文件：与组件名保持一致

### 2. 前端代码组织规范
- 使用 `<script setup>` 语法糖
- 按照"导入 → 响应式数据 → 方法 → 生命周期"顺序组织代码
- 复杂逻辑抽取为独立的 composable 函数

### 3. 前端样式规范
- 使用 scoped 样式避免污染全局
- 关键页面使用独立 CSS 文件（如 `word-learn.css`）

### 4. 前端 API 请求规范
- 统一使用 Axios 封装的请求方法
- 请求路径以 `/api` 开头，由 Vite 代理转发

### 5. 后端开发规范

**Controller 层规范：**
- 使用 @RestController 注解
- 统一返回 Result<T> 封装类
- 使用 @Valid 进行参数校验
- 添加接口文档注释

**Service 层规范：**
- 接口与实现分离
- 复杂业务使用 @Transactional 保证事务一致性
- 异常统一抛出 BusinessException

**Mapper 层规范：**
- 使用 @Mapper 注解
- 复杂 SQL 使用 XML 映射文件
- 简单 SQL 可使用注解方式

**命名规范：**
- 实体类：User、Class、Word（对应数据库表）
- DTO：LoginDTO、TaskCreateDTO（数据传输对象）
- VO：LoginVO、TaskVO（视图对象）
- Query：UserQuery、TaskQuery（查询条件对象）

---

## 七、技术选型优势总结

| 技术 | 核心优势 | 项目价值 |
|------|---------|---------|
| **Vue 3 Composition API** | 灵活的逻辑组织和复用 | 适合复杂业务场景，提升代码可维护性 |
| **Vue Router** | 强大的路由管理和守卫机制 | 实现基于角色的前端权限控制 |
| **Ant Design Vue** | 企业级组件库，60+ 组件 | 快速构建专业界面，保持视觉统一 |
| **Axios** | 统一的请求封装和拦截器 | 简化 API 调用，统一错误处理 |
| **Spring Boot** | 快速开发框架，自动配置 | 简化后端开发，支持模块化架构 |
| **MyBatis** | 灵活的 SQL 控制和映射 | 支持复杂查询和数据权限过滤 |
| **Spring Security** | 完善的安全框架 | 实现认证授权和数据级权限控制 |

这些技术的组合使得项目具备了：
- **良好的开发体验**：Vite 快速构建 + Vue 3 灵活开发 + Spring Boot 快速搭建
- **优秀的用户体验**：Ant Design 统一界面 + ECharts 数据可视化
- **完善的安全机制**：前端 Vue Router 权限控制 + 后端 Spring Security 三层防护（接口级、方法级、数据级）
- **高可维护性**：前端模块化路由 + Composition API 逻辑复用 + 后端多模块聚合工程
- **数据一致性保证**：MyBatis 事务控制 + MySQL ACID 特性
